<!DOCTYPE html>
<html>
<head>
  <meta name="description" content="Simple Password Backup">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Simple Password Backup</title>
</head>
<body>
  <script>
    /** Redacts text. */
    function splice(str, index, count) {
      let add = ''.padStart(count, 'â–ˆ')
      const indexBefore = index
      const addBefore = add
      if (index < 0) {
        add = add.substring(-index)
        index = 0;
      }
      count = add.length
      return str.slice(0, index) + (add || "") + str.slice(index + count);
    }
    
    function x() {
      try {
        const [a,b,c,d] = 'abcd'.split('').map(id => document.getElementById(id))
        const users = parseInt(a.value)
        const requiredUsers = parseInt(b.value)
        const redundantUsers = users - requiredUsers
        const pwd = c.value
        if (pwd.length < users) throw new Error('Password must be longer than backups.')
        const minUsers = Math.ceil(users / (redundantUsers + 1))
        let str = ''
        str += `Reconstruct using any ${requiredUsers} backups\n(OR ${minUsers} specific backups)\n`
        
        const gaplen = requiredUsers - 1 // how long the black gap is
        const separatorlen = redundantUsers + 1 // dist between gaps (how many are required to piece it back together)
        for (let i = 0; i < users; i++) {
          let tmp = pwd
          let x = i - gaplen
          while (x < pwd.length) {
            tmp = splice(tmp, x, gaplen)
            x += gaplen + separatorlen
          }
          str += `\n#${(i+1+'').padEnd(2, ' ')}: ${tmp.substring(0, pwd.length)}`
        }
        d.innerHTML = str + '\n\n'
      } catch (err) {
        console.log(`Error: ${err.message}`)
        d.innerHTML = `Error: ${err.message}`
      }
    }
    setTimeout(x, 100)
  </script>
  
  <style>
    label{margin-top:5px;}
    input{font-size:18px;padding:5px;}
    body{padding:15px;background:#eee;font-size:18px;display:flex;flex-direction:column;gap:15px;}
    pre{letter-spacing:5px;border:1px solid grey;padding:5px;margin:0;background:#FFF;min-height:100px;}
    hr{background:#ddd;height:1px;width:100%;}
  </style>
  
  <h1>Simple Password Backup</h1>
  <p>Split your password into multiple, partially redacted, reconstructable backups.</p>
  <p>Why? Because it's simple. You can physically divide your password amongst trusted contacts without a single point of risk. You can choose your level of redundancy. It's simple to reconstruct. And it's probably better than whatever your current master password/private key backup strategy is...</p>
  <p>Is this secure? It should be... There are no libraries, no dependencies, no connections. The code is a single, readable, 77 lines, html file. For the security conscious, this page can be saved and run in an incognito browser, from your local disk, on an air-gapped (offline) laptop.</p>
  <hr>
  <label>1. How many password backups?</label><input id="a" onkeyup="x()" autocomplete="off" placeholder="users" value="5" />
  <label>2. How many backups are needed to reconstruct the password?</label><input id="b" onkeyup="x()" autocomplete="off" placeholder="numparts" value="3" />
  <label>3. What is the Password?</label><input id="c" onkeyup="x()" autocomplete="off" placeholder="pwd" value="abcdefghijklm" />
  <label>Passwords Output - store these separately!</label><pre id="d"></pre>
  <p>NOTE: Is your redacted password guessable? Consider changing it!</p>

</body>
</html>
